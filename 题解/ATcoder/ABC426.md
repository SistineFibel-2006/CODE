### A : OS Version

题意：按照时间顺序给你三个版本号，输入两个版本号(X, Y)，询问X是否比Y要新或者是相同

题解：最简单的模拟就是用map

```cpp
/**/map<string , I> mp;
    mp["Ocelot"] = 1;
    mp["Serval"] = 2;
    mp["Lynx"] = 3;
    STR(A, B);
  	if(mp[A] < mp[B])
  		out("No");
  	else
  		out("Yes");
```

### B : The Odd One Out

题意：给你一个长度至少是3的字符串，找出其中只出现了一次的字符，保证这个串只由两种字符构成

题解：map模拟即可，记录两种字符的出现次数，输出只出现了一次的即可

```cpp
/**/STR(a);
  	map<char, int> mp;
  	each(c, a) {
  		mp[c] ++;
  	}
  	each(c, d, mp) {
  		if(d == 1)
  			return(out(c));
  	}
```

### C : Upgrade Required

题意 ：有N台电脑，版本是从1~N，有Q次升级，找到所有小于等于X版本的机器，升级到Y版本，对于每次升级，输出升级了的电脑的数量。

题解 ： 这里介绍复杂度最优的写法，对于一次升级，我们需要找到版本号是[1,X]的所有机器，然后升级到Y，答案就是$\sum_{i=1}^X cnt[i]$ 。

所以我们需要先创建一个数组pc[]，目的是记录每个版本上有多少pc，然后对于每一次升级的(X,Y)而言，如果当前最老的版本的pc的版本号比X小，那么就需要升级，所以我们用一个编号oldest记录最老版本的pc即可。

```cpp
/**/INT(n, Q);
  	vec(I, pc, n + 1); //记录每个版本上电脑的数量
  	rep(i,0,n+1) pc[i] = 1;
  	pc[0] = 0;
  	I oldest = 1; //记录现在最老的版本的电脑对应的版本号
  	rep(Q) {
  		INT(x, y);
  		i64 ans = 0;
  		while(oldest <= x) { //如果当前最老版本号比X小，那么就需要升级
  			ans += pc[oldest];
  			pc[y] += pc[oldest];
  			oldest ++;//当前版本就没有电脑了，所以最老的版本号上移
  		}
  		out(ans);
  	}
```