# 题解 ： 20250812

## A : Seats

​	题意 ： 给你一个只包含 # . 的字符串， 判断里面有多少个 形如 `#.#`的 结构！

​	解法 ： 直接模拟即可

```cpp
#include <stdio.h>
int main() {
    int n; 
    scanf("%d", &n);
    char a[200010];
    scanf("%s", a);
    int ans = 0;
    for(int i = 0; i < n - 2; i ++)
        if(a[i] == '#' && a[i + 1] == '.' && a[i + 2] == '#')
            ans ++;
    printf("%d", ans);
}
```

## B : Travel Takahashi Problem

​	题意 ： Takahashi（高桥） 从 $(0, 0)$ 出发，依次经过 给定的 N 个点，请你求出他的旅行距离。

​	解法 ： 使用浮点数存储，每一次计算一下欧氏距离即可！

> [!tip]
>
> 欧氏距离 ： 也称欧几里得距离，是最常见的距离度量，衡量的是多维空间中两个点之间的 绝对距离 。
>
> ​	公式 ： $dist = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2) ^ 2}$
>
> 在此也给出其的 C语言 表达式 :
>
> ```cpp
> double dist = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))
> ```
>
> 其中 sqrt(x) 是 $\sqrt{x}$， pow(a, b) 即 $a^b$ 

```cpp
#include <bits/stdc++.h>
int main() {
    int n;
    scanf("%d", &n);
    double ans = 0.0;
    double x1 = 0, y1 = 0;
    for(int i = 0; i < n; i ++) {
        double x, y;
        scanf("%lf %lf", &x, &y);
        ans += sqrt(pow(abs(x - x1), 2) + pow(abs(y - y1), 2));
        x1 = x, y1 = y;
    }
    ans += sqrt(pow(abs(0 - x1), 2) + pow(abs(0 - y1), 2));
    printf("%lf", ans);
}
```

> [!note]
>
> 或者你也可以直接使用 hypot(a, b) 这个函数来计算欧氏距离
>
> hypot(x1 - x2, y1 - y2) 就可以表示刚刚的式子了！

## C : Spiral Rotation

​	题意 ： 按照题目内的要求操作这个**地图**

​	题解 ： 太难了我不想写~， 回头再说！