# 题解 ： 20250810

## A : 12345

​	题意 ： 给你五个数字，满足**排列**（还记得定义么？）。 你可以**任意交换一次**相邻的两个数字，问能否将该排列变成 12345 。

> [!tip]
> 打表 ： 特有术语， 对于一些可能出现规律， 或是题目的解有**有穷性**的， 可以考虑使用暴力代码或是手动计算来列举出所有（或用于找规律的）答案， 从而提交或找到最终规律。

​	解答 ： 因为只能交换一次，所以直接**打表**即可！

```cpp
#include<stdio.h>
int main(){
  int i,n=0,a;
  for(i=0;i<5;i++){
    scanf("%d",&a);
    n=n*10+a;
  }
  if(n == 21345 || n == 13245 || n == 12435 || n == 12354 )  //直接枚举
    puts("Yes");
  else 
    puts("No");
  return 0;
}
```

## B : Geometric Sequence

​	题意 ： 给你一个正整数列，判断是否是几何级数

> [!tip]
>
> 几何级数 ： 即等比级数。

​	解答 ： 其实本身没什么难点，但是需要注意的是，由于计算机语言的除法有**误差**！所以需要使用交叉相乘的方法来避免误差。
$$
					a[1] ^ 2 = a[0] * a[2] => \frac{a[1]}{a[0]} = \frac{a[2]}{a[1]} （错误！） 
$$
​	这里就不给出枚举的代码了喵 (* ^ ▽ ^ *)

## C : Paint to make a rectangle

​	题意 ： 给你一个**地图**，里面包含 # . ?， 其中 # 表示必须涂黑的格子， . 表示白色的格子， ？表示待涂色的格子。问你，能不能涂成一个黑**矩形**！

​	解答 ： 其实这道题本身不是特别好想，需要一点思维。

​	       我们知道，如果有一个黑矩形，那么所有的 # 一定被包含在内，因为如果不全被包含，那么就不是一个单独的矩形了，不符合题意，那么我们只需要先维护黑矩形的边界，即 min_x, min_y, max_x, max_y 。 有了这四个，就可以直接枚举这四个直线围成的这个矩形内有没有 . 了，因为 . 是一定白色的， 如果有， 那么就不能， 反之则可以。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int l=N,r,u=N,d,n,m;
char a[N][N];
int main(){
	cin>>n>>m;    // C++ 的 输入， 和  scanf("%d%d", &n, &m)； 等价
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){
		cin>>a[i][j];
		if(a[i][j]=='#')l=min(l,j),r=max(r,j),u=min(u,i),d=max(d,i);
	}
	for(int i=u;i<=d;++i)for(int j=l;j<=r;++j)if(a[i][j]=='.')return puts("No"),0;
	return puts("Yes"),0;
} 
```

