# 题解 ： 20250811



## A : Not Acceptable

​	题意 ： 给你四个数字A B C D，A:B 表示一个时间， C:D 表示一个时间， 如果后者在前者之前，那么Yes，反之 No。

```cpp
#include <bits/stdc++.h>
int main() {
	int a, b, c, d; 
	scanf("%d%d%d%d", &a, &b, &c, &d);
	if(a>c) puts("Yes");
	else if(a<c) puts("No");
	else if(b>d) puts("Yes");
	else puts("No");
}
```

## B : Product Calculator

​	题意 ： 其实直接模拟即可，但是需要注意会超过`int`型的数据范围，所以需要使用`long long`。

​	这里就不给出代码了

## C : ~ 

​	前情提要，这个符号的英文叫 `tilde`,就是题目中所说的 `tilde-shape`中的那个 **~** 。

​	题意 ： 给你一个数组， 问你这个数组中是 `tilde-shape`的连续子序列数量。

> [!tip]
>
> 连续子序列 ： 是指从一个序列中截取的一段连续元素构成的子序列。其特点是元素在原序列中必须是连续的，不能跳过任何中间元素。
>
> ​	    给定一个序列 \( $A = [a_1, a_2, \dots, a_n]$ \)，其连续子序列的形式为：$[a_i, a_{i+1}, \dots, a_j]$, 其中 \( $1 \leq i \leq j \leq n$ \)。

​	tilde-shape:题目中的定义！ 指的是 先降后升再降 或 先升后降再升 的 样子的数组。

### **题意理解**

给定一个长度为 \( n \) 的序列 \( p \)，要求统计所有满足以下条件的情况：

- 存在一段连续递增的相邻元素  
- 接着一段连续递减的相邻元素  
- 再接着一段连续递增的相邻元素  

中间的递减段 `>` 夹在两个递增段 `<` 之间。  
每种情况的贡献为：
	**左段长度** * **右段长度**

这里的“长度”指的是相邻元素比较符号的个数（即箭头个数），不是元素数量。

---

### **解题思路**
1. **扫描相邻元素趋势**  
   - 如果 \(p[i] < p[i+1]\)，记为 `<`（递增符号）。  
   - 否则记为 `>`（递减符号）。

2. **压缩连续相同符号**  
   将相同趋势的符号合并成一段，记录：
   - 符号类型
   - 符号段的长度（比较次数）
   - **统计模式 `< > <`**  
      遍历压缩后的符号段数组，找到中间为 `>` 的位置，  
      对应答案累加：
                **左段长度** * **右段长度**
   
3. **输出结果**

---

### **复杂度分析**
- **时间复杂度**：  
  - 压缩：($$O(n)$$ \)  
  - 统计：\($ O(n)$ \)  
  总体：\($ O(n)$ )
- **空间复杂度**：\($O(n)$ \)  

---



```cpp
#include <stdio.h>

int p[200000];
char t[200000];
long long len[200000];

int main() {
    int n, sz = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &p[i]);
    for (int i = 0; i < n - 1; i++) {
        char c = p[i] < p[i + 1] ? '<' : '>';
        if (sz == 0 || t[sz - 1] != c) { t[sz] = c; len[sz] = 1; sz++; }
        else len[sz - 1]++;
    }
    long long ans = 0;
    for (int i = 1; i < sz - 1; i++)
        if (t[i] == '>') ans += len[i - 1] * len[i + 1];
    printf("%lld\n", ans);
    return 0;
}

```

