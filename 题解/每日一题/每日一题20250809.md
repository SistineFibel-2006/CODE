# 题解 ： 20250809

## A : AC or WA

​	题意 ： 给你两个数字分别表示 样例数目 和 通过的样例数目，直接验证两数字是否相等即可

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    if(n == m)
        puts("Yes");
    else
        puts("No");
}
```

## B : Comparing String

​	题意 ： 给你两个个位数字 $a,b$ ，问是 b 个 $a$ 还是 a 个 $b$ 的 字典序（lexicographically）更小？

> [!tip]
>
> 字典序(lexicographically) ： 字典序的大小满足下面三个规则来比较，更靠前的规则优先级更高
>
> ​				1.从第一个字符开始比较 ：逐个字符按照字母表顺序比较
>
> ​				2.第一个不同字符决定顺序 ：如果在某个位置上字符不同，字符小的（即字母表中靠前的）字符串排在前面
>
> ​				3.较短字符串排在前面 ：若所有对应字符均相同，则短的字典序靠前

​	根据字典序的定义不难发现，因为这两个新的字符串都只含有一种**字符**！所以直接比较 $a$ 和 $b$ 谁更小，谁的字典序就会更小啦！

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int a, b; 
    scanf("%d%d", &a, &b);
    if(a > b)
        for(int i = 0; i < a; i ++)
            cout << b;
    else									// 在这里的话，就算a b 相等，也是包含在这个情况内的
        for(int i = 0; i < b; i ++)
            cout << a;
}
```

## C : Low Elements

​	题意 ： 对于一个排列中的所有数，找到他是否满足，他之前的所有数字都比他大（他比他之前的所有数字都小）。

> [!tip]
>
> 排列（permutation） ： 通常特指一个长度为$n$的数组，其中包含$1$到$n$的所有整数，且每个数**恰好**只出现**一次**！

​	只需要根据题意，在每一个数字的时候更新一下当前最小值就行，如果现在这个数比之前记录的最小值更小，那么最小值更新，计数器 $+1$ 。

```cpp
#include <bits/stdc++.h>
int main(){
    int N, p = 1e6, c = 0;
    scanf("%d",&N);
    for(int i = 0; i < N; i ++){
      int a;
      scanf("%d",&a);
      if(p>a) 				//如果比之前的所有数都小
        p=a,c++;
   }
    printf("%d",c);
}
```

